<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seb's Fitness Tracker</title>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #FF3939;
            --secondary: #FFA500;
            --bg-dark: #0F0F0F;
            --bg-card: #1A1A1A;
            --text: #FFFFFF;
            --text-dim: #888888;
            --success: #00FF88;
            --border: #2A2A2A;
            --accent: #E5E5E5;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: #0F0F0F;
            color: var(--text);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(26, 26, 26, 0.5);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            border: 1px solid rgba(42, 42, 42, 0.8);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .header {
            text-align: center;
            padding: 40px 20px;
        }

        .header h1 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(3rem, 8vw, 6rem);
            letter-spacing: 0.05em;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid var(--border);
            overflow-x: auto;
        }

        .nav-tab {
            padding: 15px 25px;
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            font-family: 'Bebas Neue', sans-serif;
            letter-spacing: 0.05em;
            font-size: 1.2rem;
        }

        .nav-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .card {
            background: rgba(26, 26, 26, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 30px;
            border: 1px solid rgba(42, 42, 42, 0.6);
            margin-bottom: 20px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
        }

        .card h2 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2rem;
            letter-spacing: 0.05em;
            margin-bottom: 20px;
            color: var(--primary);
        }

        .day-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            overflow-x: auto;
        }

        .day-btn {
            padding: 10px 20px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-dim);
            cursor: pointer;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            letter-spacing: 0.05em;
            transition: all 0.3s;
        }

        .day-btn:hover {
            background: rgba(255, 57, 57, 0.1);
            border-color: var(--primary);
        }

        .day-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
            box-shadow: 0 4px 12px rgba(255, 57, 57, 0.4);
        }

        .item-list {
            list-style: none;
        }

        .item {
            background: rgba(255, 165, 0, 0.05);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 15px;
            border-left: 4px solid var(--secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
        }

        .item:hover {
            background: rgba(255, 165, 0, 0.1);
            transform: translateX(4px);
        }

        .item.completed {
            opacity: 0.5;
            border-left-color: var(--success);
        }

        .checkbox {
            width: 30px;
            height: 30px;
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .checkbox.checked {
            background: var(--success);
            border-color: var(--success);
        }

        .checkbox.checked::after {
            content: '‚úì';
            color: var(--bg-dark);
            font-weight: bold;
            font-size: 1.2rem;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-box {
            background: rgba(255, 57, 57, 0.05);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-box .value {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.5rem;
            color: var(--primary);
        }

        .stat-box .label {
            color: var(--text-dim);
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .add-form {
            background: rgba(255, 165, 0, 0.05);
            padding: 25px;
            border-radius: 12px;
            margin-top: 20px;
            border: 2px dashed var(--border);
        }

        .add-form h3 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            color: var(--secondary);
            margin-bottom: 15px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            color: var(--text-dim);
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
        }

        .btn-add {
            width: 100%;
            padding: 12px;
            background: var(--secondary);
            border: none;
            border-radius: 8px;
            color: var(--bg-dark);
            font-weight: 700;
            cursor: pointer;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
        }

        .delete-btn {
            background: rgba(255, 57, 57, 0.2);
            border: none;
            color: var(--primary);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            margin-left: 10px;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 57, 57, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--secondary) 100%);
            transition: width 0.5s ease;
        }

        .mini-card {
            background: rgba(255, 165, 0, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            border-left: 3px solid var(--secondary);
            transition: all 0.3s;
        }

        .mini-card:hover {
            background: rgba(255, 165, 0, 0.1);
        }

        .mini-card.completed {
            opacity: 0.5;
        }

        .overview-section {
            margin-top: 30px;
        }

        .overview-section h3 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            color: var(--secondary);
            margin-bottom: 15px;
        }

        .input-row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            margin-top: 15px;
        }

        .input-row input {
            padding: 12px;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text);
        }

        .btn-small {
            padding: 12px 20px;
            background: var(--primary);
            border: none;
            border-radius: 8px;
            color: var(--text);
            font-weight: 700;
            cursor: pointer;
        }

        .edit-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: rgba(255, 165, 0, 0.1);
            border: 2px solid var(--secondary);
            border-radius: 8px;
            color: var(--secondary);
            font-weight: 700;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .edit-toggle:hover {
            background: var(--secondary);
            color: var(--bg-dark);
        }

        .edit-toggle.active {
            background: var(--secondary);
            color: var(--bg-dark);
        }

        .card {
            position: relative;
        }

        .hidden {
            display: none;
        }

        .graph-trigger {
            cursor: pointer;
            background: rgba(255, 165, 0, 0.05);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid var(--border);
            transition: all 0.3s;
            text-align: center;
        }

        .graph-trigger:hover {
            border-color: var(--secondary);
            background: rgba(255, 165, 0, 0.1);
        }

        .weight-adjuster {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .weight-arrow {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary);
            border: none;
            color: var(--text);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .weight-arrow:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(255, 57, 57, 0.4);
        }

        .weight-arrow:active {
            transform: scale(0.95);
        }

        .weight-display {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 3rem;
            color: var(--primary);
            min-width: 150px;
            text-align: center;
        }

        .weight-display::-webkit-inner-spin-button,
        .weight-display::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .edit-btn {
            background: rgba(0, 100, 255, 0.2);
            border: none;
            color: #0064FF;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            margin-left: 10px;
            transition: all 0.3s;
        }

        .edit-btn:hover {
            background: #0064FF;
            color: var(--text);
        }

        .delete-icon {
            background: rgba(255, 57, 57, 0.2);
            border: none;
            color: var(--primary);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.3s;
        }

        .delete-icon:hover {
            background: var(--primary);
            color: var(--text);
        }

        .draggable {
            cursor: move;
            transition: opacity 0.2s, transform 0.2s;
        }

        .draggable:hover {
            transform: translateX(5px);
        }

        .dragging {
            opacity: 0.5;
        }

        .drag-over {
            border-top: 3px solid var(--primary);
        }

        .drag-handle {
            cursor: grab;
            color: var(--text-dim);
            font-size: 1.2rem;
            margin-right: 10px;
            user-select: none;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .ingredient-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr auto;
            gap: 10px;
            margin-bottom: 10px;
        }

        .ingredient-row input {
            padding: 10px;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
        }

        .ingredient-row input:focus {
            outline: none;
            border-color: var(--secondary);
        }

        .shopping-item {
            display: grid;
            grid-template-columns: auto 2fr 0.8fr 0.8fr 0.8fr auto;
            gap: 10px;
            align-items: center;
            background: rgba(255, 165, 0, 0.05);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 10px;
            border-left: 4px solid var(--secondary);
            transition: all 0.3s;
        }

        .shopping-item:hover {
            background: rgba(255, 165, 0, 0.1);
        }

        .shopping-item.completed {
            opacity: 0.5;
            border-left-color: var(--success);
        }

        .shopping-item .ingredient-name {
            color: var(--text);
            font-weight: 600;
        }

        .shopping-item .quantity {
            color: var(--text-dim);
            font-size: 0.9rem;
        }
        
        .shopping-item .drag-handle {
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>SEB'S FITNESS TRACKER</h1>
        </div>

        <div class="nav-tabs" id="navTabs"></div>
        <div id="content"></div>
    </div>

    <script>
        // Data
        const DAYS = ['Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'L√∏rdag', 'S√∏ndag'];
        
        const MEALS = {
            'Mandag': [],
            'Tirsdag': [],
            'Onsdag': [],
            'Torsdag': [],
            'Fredag': [],
            'L√∏rdag': [],
            'S√∏ndag': []
        };

        const WORKOUTS = {
            'Mandag': [],
            'Tirsdag': [],
            'Onsdag': [],
            'Torsdag': [],
            'Fredag': [],
            'L√∏rdag': [],
            'S√∏ndag': []
        };

        const SHOPPING = [];

        // Google Sheets API
        const GOOGLE_SHEETS_URL = 'https://script.google.com/macros/s/AKfycbzRfI_nvXqbPLozjtpjq01-tjuktxU86WDN9F2LepEH67dtujxi0EgkOISBLrs_N7rJ/exec';
        let isSyncing = false;

        // State
        let state = {
            activeTab: 'oversigt',
            selectedDay: DAYS[new Date().getDay() === 0 ? 6 : new Date().getDay() - 1],
            weight: 118,
            startWeight: 118,
            goalWeight: 95,
            meals: {},
            workouts: {},
            shopping: {}, // Now: {item: {checked: bool, quantity: string, unit: string, inventory: number}}
            modalShopping: {}, // Separate state for modal checkboxes
            shoppingOrder: [], // Custom order for shopping list items
            householdItems: [], // Dagligvarer like toilet paper, toothpaste etc
            customMeals: {}, // Cleared - user will add new meals
            customWorkouts: {},
            weightHistory: [],
            editMode: {
                stats: false,
                meals: false,
                workouts: false,
                shopping: false,
                household: false
            },
            tempWeight: 118,
            currentIngredients: [{item: '', quantity: '', unit: ''}] // Added unit field
        };

        // Initialize app
        async function initApp() {
            console.log('üöÄ Initializing Fitness Tracker...');
            
            // Try to load from cloud first
            const cloudLoaded = await loadFromCloud();
            
            if (!cloudLoaded) {
                // Fallback to localStorage
                console.log('üì¶ Loading from localStorage...');
                const saved = localStorage.getItem('fitnessData');
                if (saved) {
                    state = {...state, ...JSON.parse(saved)};
                }
            }
            
            // Check daily reset
            checkDailyReset();
            
            // Initial render
            render();
            
            console.log('‚úÖ App initialized');
        }

        // Load from localStorage (backup - removed from sync path)
        // const saved = localStorage.getItem('fitnessData');
        // if (saved) {
        //     state = {...state, ...JSON.parse(saved)};
        // }
        
        // Check if we need to reset today's completions
        function checkDailyReset() {
            const today = new Date().toDateString();
            const lastReset = localStorage.getItem('lastResetDate');
            
            if (lastReset !== today) {
                // New day! Reset today's day completions
                const currentDay = DAYS[new Date().getDay() === 0 ? 6 : new Date().getDay() - 1];
                
                // Clear meal completions for current day
                Object.keys(state.meals).forEach(key => {
                    if (key.startsWith(currentDay + '-')) {
                        delete state.meals[key];
                    }
                });
                
                // Clear workout completions for current day
                Object.keys(state.workouts).forEach(key => {
                    if (key.startsWith(currentDay + '-')) {
                        delete state.workouts[key];
                    }
                });
                
                // Save reset date
                localStorage.setItem('lastResetDate', today);
                save();
            }
        }

        function save() {
            // Save to localStorage first (instant)
            localStorage.setItem('fitnessData', JSON.stringify(state));
            
            // Sync to cloud in background (don't block UI)
            syncToCloud();
        }

        async function syncToCloud() {
            if (isSyncing) {
                console.log('‚è≥ Sync already in progress, skipping...');
                return;
            }
            
            isSyncing = true;
            console.log('‚òÅÔ∏è Syncing to Google Sheets...');
            
            try {
                // Prepare data for Google Sheets
                const payload = {
                    weightHistory: state.weightHistory || [],
                    meals: convertMealsToArray(),
                    workouts: convertWorkoutsToArray(),
                    shopping: convertShoppingToArray(),
                    householdItems: state.householdItems || [],
                    completions: convertCompletionsToArray(),
                    settings: {
                        startWeight: state.startWeight,
                        goalWeight: state.goalWeight,
                        currentWeight: state.weight
                    }
                };
                
                const response = await fetch(GOOGLE_SHEETS_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('‚úÖ Synced to cloud successfully');
                    showSyncIndicator('success');
                } else {
                    console.error('‚ùå Cloud sync failed:', result.error);
                    showSyncIndicator('error');
                }
                
            } catch (error) {
                console.error('‚ùå Cloud sync error:', error);
                showSyncIndicator('error');
            } finally {
                isSyncing = false;
            }
        }

        async function loadFromCloud() {
            console.log('‚òÅÔ∏è Loading from Google Sheets...');
            
            try {
                const response = await fetch(GOOGLE_SHEETS_URL);
                const result = await response.json();
                
                if (result.success && result.data) {
                    console.log('‚úÖ Loaded from cloud:', result.data);
                    
                    // Merge cloud data with state
                    if (result.data.weightHistory) {
                        state.weightHistory = result.data.weightHistory;
                    }
                    
                    if (result.data.meals) {
                        state.customMeals = convertMealsFromArray(result.data.meals);
                    }
                    
                    if (result.data.workouts) {
                        state.customWorkouts = convertWorkoutsFromArray(result.data.workouts);
                    }
                    
                    if (result.data.shopping) {
                        state.shopping = convertShoppingFromArray(result.data.shopping);
                        state.shoppingOrder = result.data.shopping.map(s => s.item);
                    }
                    
                    if (result.data.householdItems) {
                        state.householdItems = result.data.householdItems;
                    }
                    
                    if (result.data.completions) {
                        const completions = convertCompletionsFromArray(result.data.completions);
                        state.meals = completions.meals;
                        state.workouts = completions.workouts;
                    }
                    
                    if (result.data.settings) {
                        state.startWeight = parseFloat(result.data.settings.startWeight) || state.startWeight;
                        state.goalWeight = parseFloat(result.data.settings.goalWeight) || state.goalWeight;
                        state.weight = parseFloat(result.data.settings.currentWeight) || state.weight;
                        state.tempWeight = state.weight;
                    }
                    
                    // Save to localStorage
                    localStorage.setItem('fitnessData', JSON.stringify(state));
                    
                    return true;
                } else {
                    console.log('‚ö†Ô∏è No cloud data or error:', result.error);
                    return false;
                }
                
            } catch (error) {
                console.error('‚ùå Failed to load from cloud:', error);
                return false;
            }
        }

        function showSyncIndicator(status) {
            const indicator = document.createElement('div');
            indicator.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                background: ${status === 'success' ? 'var(--success)' : '#FF3939'};
                color: white;
                border-radius: 8px;
                font-weight: 600;
                z-index: 10000;
                animation: slideIn 0.3s ease;
            `;
            indicator.textContent = status === 'success' ? '‚úÖ Synced' : '‚ùå Sync failed';
            
            document.body.appendChild(indicator);
            
            setTimeout(() => {
                indicator.style.opacity = '0';
                indicator.style.transition = 'opacity 0.3s';
                setTimeout(() => indicator.remove(), 300);
            }, 2000);
        }

        // Helper functions to convert state to/from Google Sheets format
        function convertMealsToArray() {
            const meals = [];
            DAYS.forEach(day => {
                if (state.customMeals[day]) {
                    state.customMeals[day].forEach(meal => {
                        meals.push({
                            day: day,
                            mealId: meal.id,
                            name: meal.name,
                            desc: meal.desc,
                            cal: meal.cal || '',
                            protein: meal.protein || '',
                            carbs: meal.carbs || '',
                            fat: meal.fat || '',
                            ingredients: JSON.stringify(meal.ingredients || [])
                        });
                    });
                }
            });
            return meals;
        }

        function convertMealsFromArray(mealsArray) {
            const meals = {};
            DAYS.forEach(day => { meals[day] = []; });
            
            mealsArray.forEach(meal => {
                if (meal.day && meals[meal.day]) {
                    meals[meal.day].push({
                        id: meal.mealId,
                        name: meal.name,
                        desc: meal.desc,
                        cal: meal.cal,
                        protein: meal.protein,
                        carbs: meal.carbs,
                        fat: meal.fat,
                        ingredients: typeof meal.ingredients === 'string' ? JSON.parse(meal.ingredients) : meal.ingredients
                    });
                }
            });
            
            return meals;
        }

        function convertWorkoutsToArray() {
            const workouts = [];
            DAYS.forEach(day => {
                if (state.customWorkouts[day]) {
                    state.customWorkouts[day].forEach(workout => {
                        workouts.push({
                            day: day,
                            workoutId: workout.id,
                            name: workout.name,
                            sets: workout.sets,
                            reps: workout.reps,
                            notes: workout.notes || ''
                        });
                    });
                }
            });
            return workouts;
        }

        function convertWorkoutsFromArray(workoutsArray) {
            const workouts = {};
            DAYS.forEach(day => { workouts[day] = []; });
            
            workoutsArray.forEach(workout => {
                if (workout.day && workouts[workout.day]) {
                    workouts[workout.day].push({
                        id: workout.workoutId,
                        name: workout.name,
                        sets: workout.sets,
                        reps: workout.reps,
                        notes: workout.notes
                    });
                }
            });
            
            return workouts;
        }

        function convertShoppingToArray() {
            const shopping = [];
            const order = state.shoppingOrder || Object.keys(state.shopping);
            
            order.forEach((item, index) => {
                if (state.shopping[item]) {
                    shopping.push({
                        item: item,
                        inventory: state.shopping[item].inventory || 0,
                        unit: state.shopping[item].unit || '',
                        orderIndex: index
                    });
                }
            });
            
            return shopping;
        }

        function convertShoppingFromArray(shoppingArray) {
            const shopping = {};
            
            shoppingArray.forEach(item => {
                shopping[item.item] = {
                    inventory: item.inventory || 0,
                    unit: item.unit || ''
                };
            });
            
            return shopping;
        }

        function convertCompletionsToArray() {
            const completions = [];
            
            // Meals completions
            Object.keys(state.meals).forEach(key => {
                if (state.meals[key]) {
                    const [day, itemId] = key.split('-');
                    completions.push({
                        day: day,
                        type: 'meal',
                        itemId: itemId,
                        completed: true
                    });
                }
            });
            
            // Workouts completions
            Object.keys(state.workouts).forEach(key => {
                if (state.workouts[key]) {
                    const [day, itemId] = key.split('-');
                    completions.push({
                        day: day,
                        type: 'workout',
                        itemId: itemId,
                        completed: true
                    });
                }
            });
            
            return completions;
        }

        function convertCompletionsFromArray(completionsArray) {
            const meals = {};
            const workouts = {};
            
            completionsArray.forEach(comp => {
                if (comp.completed) {
                    const key = `${comp.day}-${comp.itemId}`;
                    if (comp.type === 'meal') {
                        meals[key] = true;
                    } else if (comp.type === 'workout') {
                        workouts[key] = true;
                    }
                }
            });
            
            return { meals, workouts };
        }

        function render() {
            renderNav();
            renderContent();
            initDragAndDrop();
        }

        function initDragAndDrop() {
            const draggables = document.querySelectorAll('.draggable');
            
            draggables.forEach(draggable => {
                draggable.addEventListener('dragstart', handleDragStart);
                draggable.addEventListener('dragend', handleDragEnd);
                draggable.addEventListener('dragover', handleDragOver);
                draggable.addEventListener('drop', handleDrop);
                draggable.addEventListener('dragenter', handleDragEnter);
                draggable.addEventListener('dragleave', handleDragLeave);
            });
        }

        let draggedElement = null;
        let draggedIndex = null;
        let draggedType = null;

        function handleDragStart(e) {
            draggedElement = this;
            draggedIndex = parseInt(this.dataset.index);
            draggedType = this.dataset.type;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            // Add drag-over class to entire item if same type
            if (this.dataset.type === draggedType && this !== draggedElement) {
                this.classList.add('drag-over');
            }
            
            return false;
        }

        function handleDragEnter(e) {
            e.preventDefault();
            if (this.dataset.type === draggedType && this !== draggedElement) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            // Only remove if we're actually leaving the element
            if (e.target === this) {
                this.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            this.classList.remove('drag-over');
            
            const dropIndex = parseInt(this.dataset.index);
            
            if (draggedIndex !== dropIndex && this.dataset.type === draggedType) {
                if (draggedType === 'meal') {
                    reorderMeals(draggedIndex, dropIndex);
                } else if (draggedType === 'workout') {
                    reorderWorkouts(draggedIndex, dropIndex);
                } else if (draggedType === 'shopping') {
                    reorderShopping(draggedIndex, dropIndex);
                }
            }
            
            return false;
        }

        function reorderShopping(fromIndex, toIndex) {
            // Get current shopping items in display order
            const aggregatedItems = {};
            
            // Add ingredients from meals
            DAYS.forEach(day => {
                if (state.customMeals[day]) {
                    state.customMeals[day].forEach(meal => {
                        if (meal.ingredients) {
                            meal.ingredients.forEach(ing => {
                                if (ing.item && !aggregatedItems[ing.item]) {
                                    aggregatedItems[ing.item] = true;
                                }
                            });
                        }
                    });
                }
            });
            
            // Add household items
            if (state.householdItems && state.householdItems.length > 0) {
                state.householdItems.forEach(item => {
                    aggregatedItems[item.name] = true;
                });
            }
            
            let itemKeys = Object.keys(aggregatedItems);
            
            // Apply current order
            if (state.shoppingOrder && state.shoppingOrder.length > 0) {
                itemKeys.sort((a, b) => {
                    const indexA = state.shoppingOrder.indexOf(a);
                    const indexB = state.shoppingOrder.indexOf(b);
                    if (indexA === -1 && indexB === -1) return a.localeCompare(b);
                    if (indexA === -1) return 1;
                    if (indexB === -1) return -1;
                    return indexA - indexB;
                });
            } else {
                itemKeys.sort();
            }
            
            // Reorder
            const [movedItem] = itemKeys.splice(fromIndex, 1);
            itemKeys.splice(toIndex, 0, movedItem);
            
            // Save new order
            state.shoppingOrder = itemKeys;
            
            save();
            render();
        }

        function reorderMeals(fromIndex, toIndex) {
            // Get converted meal names
            const convertedNames = new Set();
            if (state.customMeals[state.selectedDay]) {
                state.customMeals[state.selectedDay].forEach(m => {
                    if (m.originalName) convertedNames.add(m.originalName);
                });
            }
            
            // Build combined array
            const defaultMeals = (MEALS[state.selectedDay] || []).filter(m => !convertedNames.has(m.name));
            const allMeals = [...defaultMeals, ...(state.customMeals[state.selectedDay] || [])];
            
            // Reorder
            const [movedItem] = allMeals.splice(fromIndex, 1);
            allMeals.splice(toIndex, 0, movedItem);
            
            // Update state - we need to rebuild the arrays
            // For simplicity, convert all to custom meals with order property
            if (!state.customMeals[state.selectedDay]) state.customMeals[state.selectedDay] = [];
            
            // Clear and rebuild with new order
            state.customMeals[state.selectedDay] = allMeals.map((m, idx) => ({
                ...m,
                id: m.id || Date.now() + idx,
                order: idx
            }));
            
            save();
            render();
        }

        function reorderWorkouts(fromIndex, toIndex) {
            // Get converted workout names
            const convertedNames = new Set();
            if (state.customWorkouts[state.selectedDay]) {
                state.customWorkouts[state.selectedDay].forEach(w => {
                    if (w.originalName) convertedNames.add(w.originalName);
                });
            }
            
            // Build combined array
            const defaultWorkouts = (WORKOUTS[state.selectedDay] || []).filter(w => !convertedNames.has(w.name));
            const allWorkouts = [...defaultWorkouts, ...(state.customWorkouts[state.selectedDay] || [])];
            
            // Reorder
            const [movedItem] = allWorkouts.splice(fromIndex, 1);
            allWorkouts.splice(toIndex, 0, movedItem);
            
            // Update state
            if (!state.customWorkouts[state.selectedDay]) state.customWorkouts[state.selectedDay] = [];
            
            // Clear and rebuild with new order
            state.customWorkouts[state.selectedDay] = allWorkouts.map((w, idx) => ({
                ...w,
                id: w.id || Date.now() + idx,
                order: idx
            }));
            
            save();
            render();
        }

        function renderNav() {
            const nav = document.getElementById('navTabs');
            nav.innerHTML = `
                <button class="nav-tab ${state.activeTab === 'oversigt' ? 'active' : ''}" onclick="setTab('oversigt')">Oversigt</button>
                <button class="nav-tab ${state.activeTab === 'tr√¶ning' ? 'active' : ''}" onclick="setTab('tr√¶ning')">Tr√¶ning</button>
                <button class="nav-tab ${state.activeTab === 'kost' ? 'active' : ''}" onclick="setTab('kost')">Kostplan</button>
                <button class="nav-tab ${state.activeTab === 'dagligvarer' ? 'active' : ''}" onclick="setTab('dagligvarer')">Dagligvarer</button>
                <button class="nav-tab ${state.activeTab === 'indk√∏b' ? 'active' : ''}" onclick="setTab('indk√∏b')">Indk√∏b</button>
            `;
        }

        function renderContent() {
            const content = document.getElementById('content');
            if (state.activeTab === 'oversigt') content.innerHTML = renderOversigt();
            if (state.activeTab === 'tr√¶ning') content.innerHTML = renderTr√¶ning();
            if (state.activeTab === 'kost') {
                content.innerHTML = renderKost();
                renderIngredientRows(); // Render after DOM is ready
            }
            if (state.activeTab === 'dagligvarer') content.innerHTML = renderDagligvarer();
            if (state.activeTab === 'indk√∏b') content.innerHTML = renderIndk√∏b();
        }

        function renderIngredientRows() {
            const container = document.getElementById('ingredientRows');
            if (!container) return;
            
            // Ensure at least one empty row
            if (state.currentIngredients.length === 0 || 
                state.currentIngredients[state.currentIngredients.length - 1].item || 
                state.currentIngredients[state.currentIngredients.length - 1].quantity ||
                state.currentIngredients[state.currentIngredients.length - 1].unit) {
                state.currentIngredients.push({item: '', quantity: '', unit: ''});
            }
            
            // Get all existing ingredients for suggestions
            const allIngredients = new Set();
            Object.values(state.customMeals).forEach(dayMeals => {
                dayMeals.forEach(meal => {
                    if (meal.ingredients) {
                        meal.ingredients.forEach(ing => allIngredients.add(ing.item));
                    }
                });
            });
            
            container.innerHTML = state.currentIngredients.map((ing, idx) => `
                <div class="ingredient-row">
                    <input 
                        type="text" 
                        list="ingredientSuggestions"
                        value="${ing.item || ''}"
                        placeholder="Ingrediens (f.eks. √¶bler)"
                        data-idx="${idx}"
                        data-field="item"
                        onblur="updateIngredient(${idx}, 'item', this.value)"
                        onkeyup="if(event.key==='Enter') updateIngredient(${idx}, 'item', this.value)"
                    />
                    <input 
                        type="text"
                        value="${ing.quantity || ''}"
                        placeholder="Antal (f.eks. 2)"
                        data-idx="${idx}"
                        data-field="quantity"
                        onblur="updateIngredient(${idx}, 'quantity', this.value)"
                        onkeyup="if(event.key==='Enter') updateIngredient(${idx}, 'quantity', this.value)"
                    />
                    <input 
                        type="text"
                        value="${ing.unit || ''}"
                        placeholder="Enhed (f.eks. stk)"
                        list="unitSuggestions"
                        data-idx="${idx}"
                        data-field="unit"
                        onblur="updateIngredient(${idx}, 'unit', this.value)"
                        onkeyup="if(event.key==='Enter') updateIngredient(${idx}, 'unit', this.value)"
                    />
                    ${state.currentIngredients.length > 1 ? `
                        <button type="button" class="delete-icon" onclick="removeIngredientRow(${idx})">‚úï</button>
                    ` : '<div style="width: 30px"></div>'}
                </div>
            `).join('') + `
                <datalist id="ingredientSuggestions">
                    ${Array.from(allIngredients).map(item => `<option value="${item}">`).join('')}
                </datalist>
                <datalist id="unitSuggestions">
                    <option value="stk">
                    <option value="g">
                    <option value="kg">
                    <option value="ml">
                    <option value="l">
                    <option value="dl">
                    <option value="spsk">
                    <option value="tsk">
                    <option value="pakke">
                    <option value="d√•se">
                </datalist>
            `;
        }

        function updateIngredient(idx, field, value) {
            // Save the currently focused element
            const activeElement = document.activeElement;
            const wasIngredientInput = activeElement && activeElement.getAttribute('data-idx') == idx;
            
            state.currentIngredients[idx][field] = value;
            
            // Check if we need to add a new row
            const lastRow = state.currentIngredients[state.currentIngredients.length - 1];
            if (lastRow.item || lastRow.quantity || lastRow.unit) {
                state.currentIngredients.push({item: '', quantity: '', unit: ''});
                renderIngredientRows();
                
                // Restore focus if it was an ingredient input
                if (wasIngredientInput) {
                    const inputs = document.querySelectorAll(`input[data-idx="${idx}"]`);
                    if (inputs[0]) inputs[0].focus();
                }
            }
        }

        function removeIngredientRow(idx) {
            state.currentIngredients.splice(idx, 1);
            if (state.currentIngredients.length === 0) {
                state.currentIngredients.push({item: '', quantity: '', unit: ''});
            }
            renderIngredientRows();
        }

        function getProgressColor(percentage) {
            // Red (0%) -> Yellow (50%) -> Green (100%)
            if (percentage === 0) return '#FF3939';
            if (percentage === 100) return '#00FF88';
            
            if (percentage < 50) {
                // Red to Yellow
                const ratio = percentage / 50;
                const r = 255;
                const g = Math.round(57 + (255 - 57) * ratio);
                const b = Math.round(57 * (1 - ratio));
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Yellow to Green
                const ratio = (percentage - 50) / 50;
                const r = Math.round(255 * (1 - ratio));
                const g = 255;
                const b = Math.round(136 + (136 * ratio));
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        function renderOversigt() {
            // Get converted meal names to hide originals
            const convertedMealNames = new Set();
            if (state.customMeals[state.selectedDay]) {
                state.customMeals[state.selectedDay].forEach(m => {
                    if (m.originalName) convertedMealNames.add(m.originalName);
                });
            }
            
            // Get converted workout names to hide originals
            const convertedWorkoutNames = new Set();
            if (state.customWorkouts[state.selectedDay]) {
                state.customWorkouts[state.selectedDay].forEach(w => {
                    if (w.originalName) convertedWorkoutNames.add(w.originalName);
                });
            }
            
            // Filter out converted defaults
            const defaultMeals = (MEALS[state.selectedDay] || []).filter(m => !convertedMealNames.has(m.name));
            const defaultWorkouts = (WORKOUTS[state.selectedDay] || []).filter(w => !convertedWorkoutNames.has(w.name));
            
            const allMeals = [...defaultMeals, ...(state.customMeals[state.selectedDay] || [])];
            const allWorkouts = [...defaultWorkouts, ...(state.customWorkouts[state.selectedDay] || [])];
            
            const completedMeals = allMeals.filter(m => state.meals[`${state.selectedDay}-${m.name || m.id}`]).length;
            const completedWorkouts = allWorkouts.filter(w => state.workouts[`${state.selectedDay}-${w.name || w.id}`]).length;
            const mealProg = allMeals.length > 0 ? (completedMeals / allMeals.length) * 100 : 0;
            const workoutProg = allWorkouts.length > 0 ? (completedWorkouts / allWorkouts.length) * 100 : 0;

            return `
                <div class="card">
                    <button class="edit-toggle ${state.editMode.stats ? 'active' : ''}" onclick="toggleEditMode('stats')">
                        ${state.editMode.stats ? '‚úì F√¶rdig' : '‚úèÔ∏è Rediger'}
                    </button>
                    
                    <h2>Dine Stats</h2>
                    
                    ${state.editMode.stats ? `
                        <div class="weight-adjuster">
                            <button class="weight-arrow" onclick="adjustWeight(-0.1)">‚óÄ</button>
                            <input 
                                type="number" 
                                step="0.1" 
                                class="weight-display" 
                                value="${state.tempWeight.toFixed(1)}"
                                onchange="state.tempWeight = parseFloat(this.value); render();"
                                style="border: 2px solid var(--primary); background: var(--bg-dark); border-radius: 12px; padding: 10px; text-align: center; cursor: text;"
                            />
                            <button class="weight-arrow" onclick="adjustWeight(0.1)">‚ñ∂</button>
                        </div>
                        <p style="text-align: center; color: var(--text-dim); margin-bottom: 20px">Juster din nuv√¶rende v√¶gt</p>
                    ` : `
                        <div class="stat-grid">
                            <div class="stat-box">
                                <div class="value">${state.weight.toFixed(1)} <span style="font-size: 1.5rem">kg</span></div>
                                <div class="label">NUV√ÜRENDE</div>
                            </div>
                            <div class="stat-box">
                                <div class="value">${(state.startWeight - state.weight).toFixed(1)} <span style="font-size: 1.5rem">kg</span></div>
                                <div class="label">TABT</div>
                            </div>
                            <div class="stat-box">
                                <div class="value">${Math.max(0, state.weight - state.goalWeight).toFixed(1)} <span style="font-size: 1.5rem">kg</span></div>
                                <div class="label">TIL M√ÖL</div>
                            </div>
                        </div>
                    `}

                    <div style="margin-top: 20px" class="${state.editMode.stats ? '' : 'hidden'}">
                        <h3 style="font-size: 1.2rem; margin-bottom: 10px; color: var(--secondary)">Juster M√•l</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Startv√¶gt (kg)</label>
                                <input type="number" step="0.1" id="startWeightInput" value="${state.startWeight}">
                            </div>
                            <div class="form-group">
                                <label>M√•lv√¶gt (kg)</label>
                                <input type="number" step="0.1" id="goalWeightInput" value="${state.goalWeight}">
                            </div>
                        </div>
                    </div>

                    ${state.weightHistory.length > 0 ? `
                        <div style="margin-top: 30px">
                            <h3 style="font-size: 1.2rem; margin-bottom: 15px; color: var(--secondary)">V√¶gtprogression</h3>
                            <div class="graph-trigger" onclick="showWeightGraph()">
                                <p style="color: var(--secondary); font-weight: 700; font-size: 1.2rem; margin-bottom: 5px">üìä KLIK FOR AT SE GRAF</p>
                                <p style="color: var(--text-dim); font-size: 0.9rem">${state.weightHistory.length} m√•linger registreret</p>
                            </div>
                        </div>
                    ` : `
                        <div style="margin-top: 30px; padding: 20px; background: rgba(255, 165, 0, 0.05); border-radius: 12px; text-align: center">
                            <p style="color: var(--text-dim)">üìà Opdater din v√¶gt for at se progression</p>
                        </div>
                    `}
                </div>

                <div class="card">
                    <h2>${state.selectedDay}</h2>
                    ${renderDaySelector()}
                    <p style="margin-bottom: 10px">M√•ltider: ${completedMeals}/${allMeals.length}</p>
                    <div class="progress-bar"><div class="progress-fill" style="width: ${mealProg}%; background: ${getProgressColor(mealProg)}"></div></div>
                    <p style="margin: 20px 0 10px">Tr√¶ning: ${completedWorkouts}/${allWorkouts.length}</p>
                    <div class="progress-bar"><div class="progress-fill" style="width: ${workoutProg}%; background: ${getProgressColor(workoutProg)}"></div></div>

                    <div class="overview-section">
                        <h3>M√•ltider</h3>
                        ${allMeals.length === 0 ? '<p style="color: var(--text-dim)">Ingen m√•ltider</p>' : allMeals.map(m => {
                            const key = `${state.selectedDay}-${m.name || m.id}`;
                            return `<div class="mini-card ${state.meals[key] ? 'completed' : ''}" style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="flex: 1;">
                                    <strong>${m.name}</strong><br>
                                    <span style="color: var(--text-dim); font-size: 0.9rem">${m.desc}</span>
                                    ${m.cal ? `<br><span style="color: var(--secondary); font-size: 0.85rem">${m.cal} kcal | P: ${m.protein || 0}g | K: ${m.carbs || 0}g | F: ${m.fat || 0}g</span>` : ''}
                                </div>
                                <div class="checkbox ${state.meals[key] ? 'checked' : ''}" onclick="toggleMeal('${m.name || m.id}')"></div>
                            </div>`;
                        }).join('')}
                    </div>

                    <div class="overview-section">
                        <h3>Tr√¶ning</h3>
                        ${allWorkouts.length === 0 ? '<p style="color: var(--text-dim)">Hviledag üéâ</p>' : allWorkouts.map(w => {
                            const key = `${state.selectedDay}-${w.name || w.id}`;
                            return `<div class="mini-card ${state.workouts[key] ? 'completed' : ''}" style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="flex: 1;">
                                    <strong>${w.name}</strong><br>
                                    <span style="color: var(--text-dim); font-size: 0.9rem">${w.sets} s√¶t √ó ${w.reps}</span>
                                    ${w.notes ? `<br><span style="font-style: italic; color: var(--text-dim); font-size: 0.85rem">(${w.notes})</span>` : ''}
                                </div>
                                <div class="checkbox ${state.workouts[key] ? 'checked' : ''}" onclick="toggleWorkout('${w.name || w.id}')"></div>
                            </div>`;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        function renderKost() {
            // Get converted meal names to hide originals
            const convertedNames = new Set();
            if (state.customMeals[state.selectedDay]) {
                state.customMeals[state.selectedDay].forEach(m => {
                    if (m.originalName) convertedNames.add(m.originalName);
                });
            }
            
            // Filter out converted default meals
            const defaultMeals = (MEALS[state.selectedDay] || []).filter(m => !convertedNames.has(m.name));
            const allMeals = [...defaultMeals, ...(state.customMeals[state.selectedDay] || [])];
            
            // Calculate total macros
            const totals = allMeals.reduce((acc, m) => {
                acc.cal += m.cal || 0;
                acc.protein += m.protein || 0;
                acc.carbs += m.carbs || 0;
                acc.fat += m.fat || 0;
                return acc;
            }, {cal: 0, protein: 0, carbs: 0, fat: 0});
            
            return `
                <div class="card">
                    <button class="edit-toggle ${state.editMode.meals ? 'active' : ''}" onclick="toggleEditMode('meals')">
                        ${state.editMode.meals ? '‚úì F√¶rdig' : '‚úèÔ∏è Rediger'}
                    </button>
                    
                    <h2>Kostplan</h2>
                    ${allMeals.length > 0 ? `
                        <p style="color: var(--secondary); font-size: 0.95rem; margin: 10px 0; font-weight: 600;">
                            Kcal: ${totals.cal} | P: ${totals.protein}g | K: ${totals.carbs}g | F: ${totals.fat}g
                        </p>
                    ` : ''}
                    ${renderDaySelector()}
                    <ul class="item-list">
                        ${allMeals.map((m, i) => {
                            const key = `${state.selectedDay}-${m.name || m.id}`;
                            const isCustom = !!m.id;
                            const editId = m.id || m.name; // Always use ID if available
                            return `<li class="item ${state.meals[key] ? 'completed' : ''} ${state.editMode.meals ? 'draggable' : ''}" ${state.editMode.meals ? 'draggable="true"' : ''} data-index="${i}" data-type="meal">
                                <div style="display: flex; align-items: center; flex: 1;">
                                    ${state.editMode.meals ? '<span class="drag-handle">‚ãÆ‚ãÆ</span>' : ''}
                                    <div style="flex: 1">
                                        <strong>${m.name}</strong><br>
                                        <span style="color: var(--text-dim); font-size: 0.9rem">${m.desc}</span>
                                        ${m.cal ? `<br><span style="color: var(--secondary); font-size: 0.85rem">${m.cal} kcal | P: ${m.protein || 0}g | K: ${m.carbs || 0}g | F: ${m.fat || 0}g</span>` : ''}
                                    </div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px">
                                    <div class="checkbox ${state.meals[key] ? 'checked' : ''}" onclick="toggleMeal('${m.name || m.id}')"></div>
                                    ${state.editMode.meals ? `
                                        <button class="edit-btn" onclick="loadMealToEdit('${editId}', ${isCustom})">Ret</button>
                                        <button class="delete-icon" onclick="confirmDeleteMeal('${editId}', ${isCustom})">‚úï</button>
                                    ` : ''}
                                </div>
                            </li>`;
                        }).join('')}
                    </ul>

                    <div class="add-form ${state.editMode.meals ? '' : 'hidden'}">
                        <h3 id="mealFormTitle">+ Tilf√∏j M√•ltid</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>M√•ltid navn</label>
                                <input type="text" id="mealName" placeholder="F.eks. Morgenmad">
                            </div>
                            <div class="form-group">
                                <label>Beskrivelse</label>
                                <input type="text" id="mealDesc" placeholder="F.eks. Skyr med b√¶r">
                            </div>
                        </div>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Kalorier (kcal)</label>
                                <input type="number" id="mealCal" placeholder="300">
                            </div>
                            <div class="form-group">
                                <label>Protein (g)</label>
                                <input type="number" id="mealProtein" placeholder="25">
                            </div>
                            <div class="form-group">
                                <label>Kulhydrater (g)</label>
                                <input type="number" id="mealCarbs" placeholder="40">
                            </div>
                            <div class="form-group">
                                <label>Fedt (g)</label>
                                <input type="number" id="mealFat" placeholder="10">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Ingredienser</label>
                            <div id="ingredientRows"></div>
                        </div>
                        <input type="hidden" id="editingMealId" value="">
                        <button class="btn-add" id="mealSaveBtn" onclick="saveMeal()">+ Tilf√∏j M√•ltid</button>
                    </div>
                </div>
            `;
        }

        function renderTr√¶ning() {
            // Get converted workout names to hide originals
            const convertedNames = new Set();
            if (state.customWorkouts[state.selectedDay]) {
                state.customWorkouts[state.selectedDay].forEach(w => {
                    if (w.originalName) convertedNames.add(w.originalName);
                });
            }
            
            // Filter out converted default workouts
            const defaultWorkouts = (WORKOUTS[state.selectedDay] || []).filter(w => !convertedNames.has(w.name));
            const allWorkouts = [...defaultWorkouts, ...(state.customWorkouts[state.selectedDay] || [])];
            
            return `
                <div class="card">
                    <button class="edit-toggle ${state.editMode.workouts ? 'active' : ''}" onclick="toggleEditMode('workouts')">
                        ${state.editMode.workouts ? '‚úì F√¶rdig' : '‚úèÔ∏è Rediger'}
                    </button>
                    
                    <h2>Tr√¶ning</h2>
                    ${renderDaySelector()}
                    ${allWorkouts.length === 0 ? '<p style="color: var(--text-dim); margin: 20px 0">Hviledag üéâ</p>' : `
                    <ul class="item-list">
                        ${allWorkouts.map((w, i) => {
                            const key = `${state.selectedDay}-${w.name || w.id}`;
                            const isCustom = !!w.id;
                            const editId = w.id || w.name; // Always use ID if available
                            return `<li class="item ${state.workouts[key] ? 'completed' : ''} ${state.editMode.workouts ? 'draggable' : ''}" ${state.editMode.workouts ? 'draggable="true"' : ''} data-index="${i}" data-type="workout">
                                <div style="display: flex; align-items: center; flex: 1;">
                                    ${state.editMode.workouts ? '<span class="drag-handle">‚ãÆ‚ãÆ</span>' : ''}
                                    <div style="flex: 1">
                                        <strong>${w.name}</strong><br>
                                        <span style="color: var(--text-dim); font-size: 0.9rem">${w.sets} s√¶t √ó ${w.reps}</span>
                                        ${w.notes ? `<br><span style="font-style: italic; color: var(--text-dim); font-size: 0.85rem">(${w.notes})</span>` : ''}
                                    </div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px">
                                    <div class="checkbox ${state.workouts[key] ? 'checked' : ''}" onclick="toggleWorkout('${w.name || w.id}')"></div>
                                    ${state.editMode.workouts ? `
                                        <button class="edit-btn" onclick="loadWorkoutToEdit('${editId}', ${isCustom})">Ret</button>
                                        <button class="delete-icon" onclick="confirmDeleteWorkout('${editId}', ${isCustom})">‚úï</button>
                                    ` : ''}
                                </div>
                            </li>`;
                        }).join('')}
                    </ul>`}

                    <div class="add-form ${state.editMode.workouts ? '' : 'hidden'}">
                        <h3 id="workoutFormTitle">+ Tilf√∏j √òvelse</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>√òvelse</label>
                                <input type="text" id="exName" placeholder="F.eks. Bicep Curls">
                            </div>
                            <div class="form-group">
                                <label>S√¶t</label>
                                <input type="text" id="exSets" placeholder="3">
                            </div>
                            <div class="form-group">
                                <label>Reps/Tid</label>
                                <input type="text" id="exReps" placeholder="10-12 eller 30 sek">
                            </div>
                            <div class="form-group">
                                <label>Noter (valgfri)</label>
                                <input type="text" id="exNotes" placeholder="per arm, let v√¶gt">
                            </div>
                        </div>
                        <input type="hidden" id="editingWorkoutId" value="">
                        <button class="btn-add" id="workoutSaveBtn" onclick="saveWorkout()">+ Tilf√∏j √òvelse</button>
                    </div>
                </div>
            `;
        }

        function renderDagligvarer() {
            return `
                <div class="card">
                    <button class="edit-toggle ${state.editMode.household ? 'active' : ''}" onclick="toggleEditMode('household')">
                        ${state.editMode.household ? '‚úì F√¶rdig' : '‚úèÔ∏è Rediger'}
                    </button>
                    
                    <h2>Dagligvarer</h2>
                    <p style="color: var(--text-dim); margin-bottom: 20px">Toilet papir, tandpasta, shampoo osv.</p>
                    
                    ${state.householdItems.length === 0 ? `
                        <p style="color: var(--text-dim); text-align: center; padding: 40px 20px">
                            üß¥ Ingen dagligvarer endnu<br>
                            <span style="font-size: 0.9rem">Klik Rediger for at tilf√∏je</span>
                        </p>
                    ` : `
                        <ul class="item-list">
                            ${state.householdItems.map((item, i) => {
                                const key = `household-${item.name}`;
                                return `<li class="item">
                                    <div style="flex: 1">
                                        <strong>${item.name}</strong>
                                        ${item.quantity || item.unit ? `<br><span style="color: var(--text-dim); font-size: 0.9rem">${item.quantity || ''} ${item.unit || ''}</span>` : ''}
                                    </div>
                                    ${state.editMode.household ? `
                                        <div style="display: flex; align-items: center; gap: 10px">
                                            <button class="edit-btn" onclick="editHouseholdItem(${i})">Ret</button>
                                            <button class="delete-icon" onclick="deleteHouseholdItem(${i})">‚úï</button>
                                        </div>
                                    ` : ''}
                                </li>`;
                            }).join('')}
                        </ul>
                    `}
                    
                    <div class="add-form ${state.editMode.household ? '' : 'hidden'}">
                        <h3 id="householdFormTitle">Tilf√∏j Dagligvare</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Navn</label>
                                <input type="text" id="householdName" placeholder="f.eks. Toilet papir">
                            </div>
                            <div class="form-group">
                                <label>Antal</label>
                                <input type="number" step="1" id="householdQuantity" placeholder="f.eks. 12">
                            </div>
                            <div class="form-group">
                                <label>Enhed</label>
                                <input type="text" id="householdUnit" list="unitSuggestions" placeholder="f.eks. ruller">
                                <datalist id="unitSuggestions">
                                    <option value="stk">
                                    <option value="g">
                                    <option value="kg">
                                    <option value="ml">
                                    <option value="l">
                                    <option value="dl">
                                    <option value="spsk">
                                    <option value="tsk">
                                    <option value="pakke">
                                    <option value="d√•se">
                                    <option value="ruller">
                                    <option value="tube">
                                    <option value="flaske">
                                </datalist>
                            </div>
                        </div>
                        <input type="hidden" id="editingHouseholdIndex" value="">
                        <button class="btn-add" id="householdSaveBtn" onclick="saveHouseholdItem()">+ Tilf√∏j Vare</button>
                    </div>
                </div>
            `;
        }

        function saveHouseholdItem() {
            const name = document.getElementById('householdName').value.trim();
            const quantity = document.getElementById('householdQuantity').value.trim();
            const unit = document.getElementById('householdUnit').value.trim();
            const editingIndex = document.getElementById('editingHouseholdIndex').value;
            
            if (!name) {
                alert('Indtast venligst et navn');
                return;
            }
            
            if (!state.householdItems) state.householdItems = [];
            
            if (editingIndex !== '') {
                // Update existing
                state.householdItems[parseInt(editingIndex)] = {name, quantity, unit};
            } else {
                // Add new
                state.householdItems.push({name, quantity, unit});
            }
            
            // Reset form
            document.getElementById('householdName').value = '';
            document.getElementById('householdQuantity').value = '';
            document.getElementById('householdUnit').value = '';
            document.getElementById('editingHouseholdIndex').value = '';
            document.getElementById('householdFormTitle').textContent = 'Tilf√∏j Dagligvare';
            document.getElementById('householdSaveBtn').textContent = '+ Tilf√∏j Vare';
            
            save();
            render();
        }

        function editHouseholdItem(index) {
            const item = state.householdItems[index];
            document.getElementById('householdName').value = item.name;
            document.getElementById('householdQuantity').value = item.quantity || '';
            document.getElementById('householdUnit').value = item.unit || '';
            document.getElementById('editingHouseholdIndex').value = index;
            document.getElementById('householdFormTitle').textContent = '‚úèÔ∏è Ret Dagligvare';
            document.getElementById('householdSaveBtn').textContent = '‚úì Gem √Ündringer';
            document.querySelector('.add-form').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function deleteHouseholdItem(index) {
            if (confirm('Er du sikker p√• at du vil slette denne vare?')) {
                state.householdItems.splice(index, 1);
                save();
                render();
            }
        }

        function renderIndk√∏b() {
            // Aggregate all ingredients from all meals across all days
            const aggregatedItems = {};
            
            DAYS.forEach(day => {
                if (state.customMeals[day]) {
                    state.customMeals[day].forEach(meal => {
                        if (meal.ingredients) {
                            meal.ingredients.forEach(ing => {
                                if (ing.item) {
                                    if (!aggregatedItems[ing.item]) {
                                        aggregatedItems[ing.item] = {
                                            quantity: 0,
                                            unit: ing.unit || '',
                                            checked: state.shopping[ing.item]?.checked || false,
                                            inventory: state.shopping[ing.item]?.inventory || 0,
                                            type: 'ingredient'
                                        };
                                    }
                                    
                                    // Add quantities (try to parse as number, otherwise keep as string)
                                    const qty = parseFloat(ing.quantity);
                                    if (!isNaN(qty)) {
                                        aggregatedItems[ing.item].quantity += qty;
                                    } else {
                                        // If not a number, just append
                                        aggregatedItems[ing.item].quantity = ing.quantity;
                                    }
                                    
                                    // Use the first unit we encounter
                                    if (!aggregatedItems[ing.item].unit && ing.unit) {
                                        aggregatedItems[ing.item].unit = ing.unit;
                                    }
                                }
                            });
                        }
                    });
                }
            });
            
            // Add household items
            if (state.householdItems && state.householdItems.length > 0) {
                state.householdItems.forEach(item => {
                    // Parse quantity as number if available
                    let qty = null;
                    if (item.quantity) {
                        const parsedQty = parseFloat(item.quantity);
                        if (!isNaN(parsedQty)) {
                            qty = parsedQty;
                        }
                    }
                    
                    aggregatedItems[item.name] = {
                        quantity: qty,
                        unit: item.unit || '',
                        checked: state.shopping[item.name]?.checked || false,
                        inventory: state.shopping[item.name]?.inventory || 0,
                        type: 'household'
                    };
                });
            }
            
            // Get items in custom order, or alphabetical if no custom order
            let itemKeys = Object.keys(aggregatedItems);
            
            // Apply custom order if exists
            if (state.shoppingOrder && state.shoppingOrder.length > 0) {
                // Sort by custom order, new items go to end
                itemKeys.sort((a, b) => {
                    const indexA = state.shoppingOrder.indexOf(a);
                    const indexB = state.shoppingOrder.indexOf(b);
                    if (indexA === -1 && indexB === -1) return a.localeCompare(b);
                    if (indexA === -1) return 1;
                    if (indexB === -1) return -1;
                    return indexA - indexB;
                });
            } else {
                itemKeys.sort();
            }
            
            const totalIngredients = itemKeys.filter(k => aggregatedItems[k].type === 'ingredient').length;
            const totalHousehold = itemKeys.filter(k => aggregatedItems[k].type === 'household').length;
            
            return `
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <button class="edit-toggle ${state.editMode.shopping ? 'active' : ''}" onclick="toggleEditMode('shopping')">
                            ${state.editMode.shopping ? '‚úì F√¶rdig' : '‚úèÔ∏è Rediger'}
                        </button>
                        <button onclick="showCleanShoppingList()" style="background: var(--success); padding: 8px 16px; border: none; border-radius: 8px; color: var(--text); font-weight: 600; cursor: pointer; font-size: 0.9rem;">
                            üõí Vis Liste
                        </button>
                    </div>
                    
                    <h2>Indk√∏bsliste</h2>
                    <p style="color: var(--text-dim); margin-bottom: 20px">
                        ${totalIngredients} ingredienser + ${totalHousehold} dagligvarer
                        ${state.editMode.shopping ? ' ‚Ä¢ Tr√¶k for at √¶ndre r√¶kkef√∏lge' : ''}
                    </p>
                    ${itemKeys.length === 0 ? `
                        <p style="color: var(--text-dim); text-align: center; padding: 40px 20px">
                            üìù Ingen varer endnu<br>
                            <span style="font-size: 0.9rem">Tilf√∏j m√•ltider i Kostplan eller varer i Dagligvarer</span>
                        </p>
                    ` : `
                        <div>
                            <!-- Column Headers -->
                            <div style="display: grid; grid-template-columns: auto 2fr 0.8fr 0.8fr 0.8fr; gap: 10px; padding: 10px 15px; margin-bottom: 10px; font-weight: 600; color: var(--text-dim); font-size: 0.85rem; border-bottom: 2px solid var(--border);">
                                ${state.editMode.shopping ? '<span style="visibility: hidden;">‚ãÆ‚ãÆ</span>' : '<span style="width: 0"></span>'}
                                <div>Vare</div>
                                <div style="text-align: center;">Ejer</div>
                                <div style="text-align: center;">K√∏b</div>
                                <div style="text-align: center;">Enhed</div>
                            </div>
                            
                            ${itemKeys.map((item, i) => {
                                const data = aggregatedItems[item];
                                const needed = typeof data.quantity === 'number' ? Math.round(data.quantity - (data.inventory || 0)) : (data.inventory > 0 ? data.inventory : '-');
                                const displayNeeded = typeof needed === 'number' ? needed : needed;
                                const displayQty = typeof data.quantity === 'number' ? 
                                    (data.quantity % 1 === 0 ? data.quantity : data.quantity.toFixed(1)) : 
                                    data.quantity;
                                
                                return `
                                    <div class="shopping-item ${state.editMode.shopping ? 'draggable' : ''}" ${state.editMode.shopping ? 'draggable="true"' : ''} data-index="${i}" data-type="shopping" data-item="${item}" style="grid-template-columns: auto 2fr 0.8fr 0.8fr 0.8fr;">
                                        ${state.editMode.shopping ? '<span class="drag-handle">‚ãÆ‚ãÆ</span>' : '<span style="width: 0"></span>'}
                                        <div class="ingredient-name">
                                            ${item}
                                            ${data.type === 'household' ? '<span style="color: var(--secondary); font-size: 0.8rem; margin-left: 5px">üß¥</span>' : ''}
                                        </div>
                                        ${state.editMode.shopping ? `
                                            <input type="number" step="1" value="${Math.round(data.inventory || 0)}" 
                                                   onchange="updateInventory('${item}', this.value)" 
                                                   onmousedown="event.stopPropagation()"
                                                   onclick="event.stopPropagation(); this.select();"
                                                   onfocus="this.select()"
                                                   style="width: 60px; padding: 5px; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text); text-align: center; margin: 0 auto;"
                                                   placeholder="0">
                                        ` : `<div class="quantity" style="text-align: center;">${data.inventory > 0 ? Math.round(data.inventory) : '-'}</div>`}
                                        <div class="quantity" style="text-align: center; font-weight: ${(typeof needed === 'number' && needed > 0) || (typeof needed === 'string' && needed !== '-' && data.inventory > 0) ? '700' : 'normal'}; color: ${(typeof needed === 'number' && needed > 0) || (typeof needed === 'string' && needed !== '-' && data.inventory > 0) ? 'var(--primary)' : 'var(--text-dim)'}">
                                            ${displayNeeded}
                                        </div>
                                        <div class="quantity" style="text-align: center;">${data.unit || '-'}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        ${state.editMode.shopping ? `
                            <p style="color: var(--text-dim); margin-top: 20px; font-size: 0.85rem; font-style: italic;">
                                üí° Ejer: Hvad du har hjemme ‚Ä¢ K√∏b: Hvad du skal k√∏be
                            </p>
                        ` : ''}
                    `}
                </div>
            `;
        }

        function updateInventory(item, value) {
            if (!state.shopping[item]) {
                state.shopping[item] = {checked: false, inventory: 0};
            }
            state.shopping[item].inventory = Math.round(parseFloat(value) || 0);
            save();
            render();
        }

        function showCleanShoppingList() {
            // Aggregate all items (same logic as renderIndk√∏b)
            const aggregatedItems = {};
            
            DAYS.forEach(day => {
                if (state.customMeals[day]) {
                    state.customMeals[day].forEach(meal => {
                        if (meal.ingredients) {
                            meal.ingredients.forEach(ing => {
                                if (ing.item) {
                                    if (!aggregatedItems[ing.item]) {
                                        aggregatedItems[ing.item] = {
                                            quantity: 0,
                                            unit: ing.unit || '',
                                            checked: state.modalShopping[ing.item]?.checked || false,
                                            inventory: state.shopping[ing.item]?.inventory || 0,
                                            type: 'ingredient'
                                        };
                                    }
                                    
                                    const qty = parseFloat(ing.quantity);
                                    if (!isNaN(qty)) {
                                        aggregatedItems[ing.item].quantity += qty;
                                    } else {
                                        aggregatedItems[ing.item].quantity = ing.quantity;
                                    }
                                    
                                    if (!aggregatedItems[ing.item].unit && ing.unit) {
                                        aggregatedItems[ing.item].unit = ing.unit;
                                    }
                                }
                            });
                        }
                    });
                }
            });
            
            // Add household items
            if (state.householdItems && state.householdItems.length > 0) {
                state.householdItems.forEach(item => {
                    // Parse quantity as number if available
                    let qty = null;
                    if (item.quantity) {
                        const parsedQty = parseFloat(item.quantity);
                        if (!isNaN(parsedQty)) {
                            qty = parsedQty;
                        }
                    }
                    
                    aggregatedItems[item.name] = {
                        quantity: qty,
                        unit: item.unit || '',
                        checked: state.modalShopping[item.name]?.checked || false,
                        inventory: state.shopping[item.name]?.inventory || 0,
                        type: 'household'
                    };
                });
            }
            
            // Get items in custom order
            let itemKeys = Object.keys(aggregatedItems);
            
            if (state.shoppingOrder && state.shoppingOrder.length > 0) {
                itemKeys.sort((a, b) => {
                    const indexA = state.shoppingOrder.indexOf(a);
                    const indexB = state.shoppingOrder.indexOf(b);
                    if (indexA === -1 && indexB === -1) return a.localeCompare(b);
                    if (indexA === -1) return 1;
                    if (indexB === -1) return -1;
                    return indexA - indexB;
                });
            } else {
                itemKeys.sort();
            }
            
            const modalHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 9999; display: flex; align-items: center; justify-content: center; padding: 20px" onclick="closeShoppingModal()">
                    <div class="card" style="max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto; background: var(--bg); border: 2px solid var(--primary);" onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid var(--primary); padding-bottom: 15px;">
                            <h2 style="margin: 0; color: var(--primary);">üõí Indk√∏bsliste</h2>
                            <button class="delete-btn" onclick="closeShoppingModal()">‚úï</button>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            ${itemKeys.map((item, i) => {
                                const data = aggregatedItems[item];
                                // For ingredients: needed = quantity - inventory
                                // For household: needed = inventory (what you need to buy)
                                const needed = typeof data.quantity === 'number' 
                                    ? Math.round(data.quantity - (data.inventory || 0))
                                    : (data.inventory > 0 ? Math.round(data.inventory) : '-');
                                
                                return `
                                    <div style="display: grid; grid-template-columns: 1fr auto auto; gap: 15px; align-items: center; padding: 15px; margin-bottom: 10px; background: ${data.checked ? 'rgba(0, 255, 136, 0.1)' : 'rgba(255, 165, 0, 0.05)'}; border-radius: 12px; border-left: 4px solid ${data.checked ? 'var(--success)' : 'var(--secondary)'}; ${data.checked ? 'opacity: 0.6;' : ''}">
                                        <div>
                                            <strong style="font-size: 1.1rem; ${data.checked ? 'text-decoration: line-through;' : ''}">${item}</strong>
                                            ${data.type === 'household' ? '<span style="color: var(--secondary); font-size: 0.9rem; margin-left: 8px;">üß¥</span>' : ''}
                                        </div>
                                        <div style="font-size: 1.2rem; font-weight: 700; color: var(--primary); text-align: right;">
                                            ${needed !== '-' ? needed : ''} ${data.unit || ''}
                                        </div>
                                        <div class="checkbox ${data.checked ? 'checked' : ''}" onclick="toggleShoppingFromModal('${item}', this)" style="width: 30px; height: 30px;"></div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        
                        <div style="text-align: center; padding-top: 15px; border-top: 2px solid var(--border);">
                            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 15px;">
                                ${itemKeys.filter(k => aggregatedItems[k].checked).length} / ${itemKeys.length} afkrydset
                            </p>
                            <button onclick="completeShopping()" style="background: var(--success); color: var(--text); border: none; padding: 12px 30px; border-radius: 8px; font-weight: 700; font-size: 1rem; cursor: pointer;">
                                ‚úì K√∏b
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        function completeShopping() {
            // Transfer checked items' quantities to inventory
            Object.keys(state.modalShopping).forEach(itemName => {
                if (state.modalShopping[itemName].checked) {
                    // Find the item in aggregated list to get its needed quantity
                    let neededQty = 0;
                    
                    // Check ingredients
                    DAYS.forEach(day => {
                        if (state.customMeals[day]) {
                            state.customMeals[day].forEach(meal => {
                                if (meal.ingredients) {
                                    meal.ingredients.forEach(ing => {
                                        if (ing.item === itemName) {
                                            const qty = parseFloat(ing.quantity);
                                            if (!isNaN(qty)) {
                                                neededQty = qty;
                                            }
                                        }
                                    });
                                }
                            });
                        }
                    });
                    
                    // Check household items
                    if (state.householdItems) {
                        const householdItem = state.householdItems.find(h => h.name === itemName);
                        if (householdItem && householdItem.quantity) {
                            const qty = parseFloat(householdItem.quantity);
                            if (!isNaN(qty)) {
                                neededQty = qty;
                            }
                        }
                    }
                    
                    // Calculate what was actually bought (needed - old inventory)
                    const oldInventory = state.shopping[itemName]?.inventory || 0;
                    const bought = Math.max(0, neededQty - oldInventory);
                    
                    // Add to inventory
                    if (!state.shopping[itemName]) {
                        state.shopping[itemName] = {inventory: 0};
                    }
                    state.shopping[itemName].inventory = Math.round(oldInventory + bought);
                }
            });
            
            // Clear all modal checkboxes
            state.modalShopping = {};
            
            save();
            render();
            
            // Close modal
            document.querySelector('[style*="position: fixed"]').remove();
        }

        function toggleShoppingFromModal(item, checkboxElement) {
            // Toggle in modalShopping state only
            if (!state.modalShopping[item]) {
                state.modalShopping[item] = {checked: false};
            }
            state.modalShopping[item].checked = !state.modalShopping[item].checked;
            save();
            
            // Update the modal item visually
            const itemDiv = checkboxElement.closest('[style*="grid-template-columns"]');
            const data = state.modalShopping[item];
            if (data && data.checked) {
                itemDiv.style.background = 'rgba(0, 255, 136, 0.1)';
                itemDiv.style.borderLeftColor = 'var(--success)';
                itemDiv.style.opacity = '0.6';
                itemDiv.querySelector('strong').style.textDecoration = 'line-through';
                checkboxElement.classList.add('checked');
            } else {
                itemDiv.style.background = 'rgba(255, 165, 0, 0.05)';
                itemDiv.style.borderLeftColor = 'var(--secondary)';
                itemDiv.style.opacity = '1';
                itemDiv.querySelector('strong').style.textDecoration = 'none';
                checkboxElement.classList.remove('checked');
            }
            // Update counter
            const modal = checkboxElement.closest('.card');
            const totalChecked = Object.values(state.modalShopping).filter(s => s.checked).length;
            
            // Count total items in modal
            const allItems = modal.querySelectorAll('[style*="grid-template-columns"]').length;
            modal.querySelector('p').textContent = `${totalChecked} / ${allItems} afkrydset`;
        }

        function completeShopping() {
            // For each checked item, add the "k√∏b" amount to inventory
            Object.keys(state.modalShopping).forEach(itemName => {
                if (state.modalShopping[itemName].checked) {
                    // Find the item in aggregated list
                    let purchaseAmount = 0;
                    
                    // Check ingredients
                    DAYS.forEach(day => {
                        if (state.customMeals[day]) {
                            state.customMeals[day].forEach(meal => {
                                if (meal.ingredients) {
                                    meal.ingredients.forEach(ing => {
                                        if (ing.item === itemName) {
                                            const qty = parseFloat(ing.quantity);
                                            if (!isNaN(qty)) {
                                                purchaseAmount += qty;
                                            }
                                        }
                                    });
                                }
                            });
                        }
                    });
                    
                    // Check household items
                    if (state.householdItems) {
                        state.householdItems.forEach(item => {
                            if (item.name === itemName && item.quantity) {
                                const qty = parseFloat(item.quantity);
                                if (!isNaN(qty)) {
                                    purchaseAmount = qty;
                                }
                            }
                        });
                    }
                    
                    // Calculate how much to buy (total - current inventory)
                    const currentInventory = state.shopping[itemName]?.inventory || 0;
                    const toBuy = Math.round(purchaseAmount - currentInventory);
                    
                    // Add purchased amount to inventory
                    if (toBuy > 0) {
                        if (!state.shopping[itemName]) {
                            state.shopping[itemName] = {inventory: 0};
                        }
                        state.shopping[itemName].inventory = Math.round(purchaseAmount);
                    }
                }
            });
            
            // Reset all modal checkboxes
            state.modalShopping = {};
            
            save();
            
            // Close modal and refresh
            document.querySelector('[style*="position: fixed"]').remove();
            render();
        }

        function closeShoppingModal() {
            // Reset all modal checkboxes
            state.modalShopping = {};
            save();
            
            // Close modal
            document.querySelector('[style*="position: fixed"]').remove();
        }

        function renderDaySelector() {
            return `<div class="day-selector">
                ${DAYS.map(d => `<button class="day-btn ${state.selectedDay === d ? 'active' : ''}" onclick="setDay('${d}')">${d}</button>`).join('')}
            </div>`;
        }

        // Actions
        function setTab(tab) {
            state.activeTab = tab;
            render();
        }

        function setDay(day) {
            state.selectedDay = day;
            render();
        }

        function toggleMeal(name) {
            const key = `${state.selectedDay}-${name}`;
            state.meals[key] = !state.meals[key];
            save();
            render();
        }

        function toggleWorkout(name) {
            const key = `${state.selectedDay}-${name}`;
            state.workouts[key] = !state.workouts[key];
            save();
            render();
        }

        function toggleShopping(item) {
            // Store checkbox state separately from ingredient data
            if (!state.shopping[item]) {
                state.shopping[item] = {checked: true};
            } else if (typeof state.shopping[item] === 'boolean') {
                state.shopping[item] = {checked: !state.shopping[item]};
            } else {
                state.shopping[item].checked = !state.shopping[item].checked;
            }
            save();
            render();
        }

        function updateWeight() {
            // Only log weight if it has actually changed
            const hasChanged = state.weight !== state.tempWeight;
            
            console.log('=== UPDATE WEIGHT ===');
            console.log('Current weight:', state.weight);
            console.log('Temp weight:', state.tempWeight);
            console.log('Has changed:', hasChanged);
            
            state.weight = state.tempWeight;
            
            if (hasChanged) {
                console.log('Weight changed - adding to history');
                state.weightHistory.push({
                    date: new Date().toISOString().split('T')[0],
                    weight: state.tempWeight
                });
            } else {
                console.log('Weight unchanged - skipping history entry');
            }
            
            save();
            render();
        }

        function adjustWeight(amount) {
            state.tempWeight = Math.max(30, Math.min(300, state.tempWeight + amount));
            state.tempWeight = Math.round(state.tempWeight * 10) / 10;
            render();
        }

        function updateGoals() {
            console.log('=== UPDATE GOALS DEBUG ===');
            const startInput = document.getElementById('startWeightInput');
            const goalInput = document.getElementById('goalWeightInput');
            
            console.log('Start input element:', startInput);
            console.log('Goal input element:', goalInput);
            
            if (!startInput || !goalInput) {
                console.error('Input elements not found!');
                return;
            }
            
            console.log('Start input value:', startInput.value);
            console.log('Goal input value:', goalInput.value);
            console.log('Before - startWeight:', state.startWeight, 'goalWeight:', state.goalWeight);
            
            if (startInput.value) {
                state.startWeight = parseFloat(startInput.value);
            }
            if (goalInput.value) {
                state.goalWeight = parseFloat(goalInput.value);
            }
            
            console.log('After - startWeight:', state.startWeight, 'goalWeight:', state.goalWeight);
            
            save();
            console.log('Saved to localStorage');
            render();
        }

        function saveMeal() {
            const name = document.getElementById('mealName').value;
            const desc = document.getElementById('mealDesc').value;
            const cal = document.getElementById('mealCal').value;
            const protein = document.getElementById('mealProtein').value;
            const carbs = document.getElementById('mealCarbs').value;
            const fat = document.getElementById('mealFat').value;
            const editingId = document.getElementById('editingMealId').value;
            
            if (!name || !desc) {
                alert('Udfyld navn og beskrivelse');
                return;
            }

            // Filter out empty ingredient rows
            const ingredients = state.currentIngredients
                .filter(ing => ing.item && ing.quantity)
                .map(ing => ({
                    item: ing.item.trim(), 
                    quantity: ing.quantity.trim(),
                    unit: ing.unit ? ing.unit.trim() : ''
                }));

            const mealData = {
                name,
                desc,
                cal: cal ? parseInt(cal) : null,
                protein: protein ? parseInt(protein) : null,
                carbs: carbs ? parseInt(carbs) : null,
                fat: fat ? parseInt(fat) : null,
                ingredients
            };

            if (editingId) {
                // Check if it's a custom meal (has numeric id)
                const isCustom = !isNaN(editingId);
                
                if (isCustom) {
                    // Editing existing custom meal
                    const idx = state.customMeals[state.selectedDay]?.findIndex(m => m.id == editingId);
                    
                    if (idx >= 0) {
                        const oldMeal = state.customMeals[state.selectedDay][idx];
                        
                        // Update the meal
                        state.customMeals[state.selectedDay][idx] = {
                            id: oldMeal.id,
                            ...mealData
                        };
                        
                        // Clean up old ingredients
                        if (oldMeal.ingredients) {
                            removeIngredientsFromShopping(oldMeal.ingredients);
                        }
                    }
                } else {
                    // Editing a default meal - convert to custom
                    if (!state.customMeals[state.selectedDay]) state.customMeals[state.selectedDay] = [];
                    
                    // Check if we already converted this one
                    const existingIdx = state.customMeals[state.selectedDay].findIndex(m => m.originalName === editingId);
                    
                    if (existingIdx >= 0) {
                        // Update existing converted meal
                        const oldMeal = state.customMeals[state.selectedDay][existingIdx];
                        
                        state.customMeals[state.selectedDay][existingIdx] = {
                            id: oldMeal.id,
                            originalName: editingId,
                            ...mealData
                        };
                        
                        if (oldMeal.ingredients) {
                            removeIngredientsFromShopping(oldMeal.ingredients);
                        }
                    } else {
                        // Create new converted meal
                        state.customMeals[state.selectedDay].push({ 
                            id: Date.now(), 
                            originalName: editingId,
                            ...mealData 
                        });
                    }
                }
            } else {
                // Adding new
                if (!state.customMeals[state.selectedDay]) state.customMeals[state.selectedDay] = [];
                state.customMeals[state.selectedDay].push({ id: Date.now(), ...mealData });
            }

            // Add new ingredients to shopping (after updating meals)
            // Now we only store checked state, quantities are calculated dynamically
            ingredients.forEach(ing => {
                if (ing.item && !state.shopping[ing.item]) {
                    state.shopping[ing.item] = {checked: false};
                }
            });

            // Reset form
            document.getElementById('mealName').value = '';
            document.getElementById('mealDesc').value = '';
            document.getElementById('mealCal').value = '';
            document.getElementById('mealProtein').value = '';
            document.getElementById('mealCarbs').value = '';
            document.getElementById('mealFat').value = '';
            document.getElementById('editingMealId').value = '';
            document.getElementById('mealFormTitle').textContent = '+ Tilf√∏j M√•ltid';
            document.getElementById('mealSaveBtn').textContent = '+ Tilf√∏j M√•ltid';
            state.currentIngredients = [{item: '', quantity: '', unit: ''}];

            save();
            render();
        }

        function removeIngredientsFromShopping(ingredients) {
            if (!ingredients || ingredients.length === 0) return;
            
            ingredients.forEach(oldIng => {
                // Check if any other meal uses this ingredient
                let stillUsed = false;
                
                // Check all days and all meals
                DAYS.forEach(day => {
                    if (state.customMeals[day]) {
                        state.customMeals[day].forEach(meal => {
                            if (meal.ingredients) {
                                if (meal.ingredients.some(ing => ing.item === oldIng.item)) {
                                    stillUsed = true;
                                }
                            }
                        });
                    }
                });
                
                // Only remove if not used by any other meals
                if (!stillUsed) {
                    delete state.shopping[oldIng.item];
                }
            });
        }

        function confirmDeleteMeal(id, isCustom) {
            if (confirm('Er du sikker p√• at du vil slette dette m√•ltid?')) {
                if (isCustom) {
                    const meal = state.customMeals[state.selectedDay]?.find(m => m.id == id);
                    
                    // First remove the meal from the array
                    state.customMeals[state.selectedDay] = state.customMeals[state.selectedDay].filter(m => m.id != id);
                    
                    // Then remove ingredients (this now checks remaining meals)
                    if (meal && meal.ingredients) {
                        removeIngredientsFromShopping(meal.ingredients);
                    }
                }
                save();
                render();
            }
        }

        function loadMealToEdit(nameOrId, isCustom) {
            const allMeals = [...(MEALS[state.selectedDay] || []), ...(state.customMeals[state.selectedDay] || [])];
            
            // Find the actual current meal (not the original)
            let meal;
            if (isCustom || !isNaN(nameOrId)) {
                // It's a custom meal - find by ID
                meal = state.customMeals[state.selectedDay]?.find(m => m.id == nameOrId);
            } else {
                // It's a default meal - check if it was converted
                const converted = state.customMeals[state.selectedDay]?.find(m => m.originalName === nameOrId);
                if (converted) {
                    meal = converted;
                    nameOrId = converted.id; // Use the converted ID for editing
                } else {
                    meal = allMeals.find(m => m.name === nameOrId);
                }
            }
            
            if (!meal) return;

            document.getElementById('mealName').value = meal.name;
            document.getElementById('mealDesc').value = meal.desc;
            document.getElementById('mealCal').value = meal.cal || '';
            document.getElementById('mealProtein').value = meal.protein || '';
            document.getElementById('mealCarbs').value = meal.carbs || '';
            document.getElementById('mealFat').value = meal.fat || '';
            document.getElementById('editingMealId').value = meal.id || meal.name;
            document.getElementById('mealFormTitle').textContent = '‚úèÔ∏è Ret M√•ltid';
            document.getElementById('mealSaveBtn').textContent = '‚úì Gem √Ündringer';
            
            // Load ingredients
            if (meal.ingredients && meal.ingredients.length > 0) {
                state.currentIngredients = meal.ingredients.map(ing => ({...ing}));
            } else {
                state.currentIngredients = [{item: '', quantity: '', unit: ''}];
            }
            
            renderIngredientRows();
            document.querySelector('.add-form').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function deleteWeightEntry(dateToDelete) {
            if (confirm('Er du sikker p√• at du vil slette denne v√¶gtm√•ling?')) {
                console.log('=== DELETE WEIGHT ENTRY DEBUG ===');
                console.log('Date to delete:', dateToDelete);
                console.log('Before delete - weightHistory:', JSON.stringify(state.weightHistory));
                
                // Filter out the specific date
                const beforeLength = state.weightHistory.length;
                const newHistory = [];
                
                state.weightHistory.forEach(entry => {
                    console.log(`Comparing: "${entry.date}" === "${dateToDelete}" ?`, entry.date === dateToDelete);
                    if (entry.date !== dateToDelete) {
                        newHistory.push(entry);
                    } else {
                        console.log('DELETING:', entry);
                    }
                });
                
                state.weightHistory = newHistory;
                
                console.log('After delete - weightHistory:', JSON.stringify(state.weightHistory));
                console.log('Deleted entries:', beforeLength - state.weightHistory.length);
                
                // Force save to localStorage immediately
                localStorage.setItem('fitnessData', JSON.stringify(state));
                console.log('Saved to localStorage');
                
                // Check if there's still data
                if (state.weightHistory.length === 0) {
                    const modal = document.querySelector('[style*="position: fixed"]');
                    if (modal) modal.remove();
                    alert('Alle v√¶gtm√•linger slettet');
                    render();
                    return;
                }
                
                // Close and reopen modal with fresh data
                const modal = document.querySelector('[style*="position: fixed"]');
                if (modal) modal.remove();
                
                setTimeout(() => {
                    showWeightGraph();
                }, 100);
            }
        }

        function deleteWeightEntryByIndex(index) {
            if (confirm('Er du sikker p√• at du vil slette denne v√¶gtm√•ling?')) {
                console.log('=== DELETE BY INDEX DEBUG ===');
                console.log('Deleting index:', index);
                console.log('Before delete:', state.weightHistory.length, 'entries');
                console.log('Entry to delete:', state.weightHistory[index]);
                
                // Remove by index
                state.weightHistory.splice(index, 1);
                
                console.log('After delete:', state.weightHistory.length, 'entries');
                
                // Force save to localStorage immediately
                localStorage.setItem('fitnessData', JSON.stringify(state));
                console.log('Saved to localStorage');
                
                // Check if there's still data
                if (state.weightHistory.length === 0) {
                    const modal = document.querySelector('[style*="position: fixed"]');
                    if (modal) modal.remove();
                    alert('Alle v√¶gtm√•linger slettet');
                    render();
                    return;
                }
                
                // Close and reopen modal with fresh data
                const modal = document.querySelector('[style*="position: fixed"]');
                if (modal) modal.remove();
                
                setTimeout(() => {
                    showWeightGraph();
                }, 100);
            }
        }

        function loadWorkoutToEdit(nameOrId, isCustom) {
            const allWorkouts = [...(WORKOUTS[state.selectedDay] || []), ...(state.customWorkouts[state.selectedDay] || [])];
            
            // Find the actual current workout (not the original)
            let workout;
            if (isCustom || !isNaN(nameOrId)) {
                // It's a custom workout - find by ID
                workout = state.customWorkouts[state.selectedDay]?.find(w => w.id == nameOrId);
            } else {
                // It's a default workout - check if it was converted
                const converted = state.customWorkouts[state.selectedDay]?.find(w => w.originalName === nameOrId);
                if (converted) {
                    workout = converted;
                    nameOrId = converted.id; // Use the converted ID for editing
                } else {
                    workout = allWorkouts.find(w => w.name === nameOrId);
                }
            }
            
            if (!workout) return;

            document.getElementById('exName').value = workout.name;
            document.getElementById('exSets').value = workout.sets;
            document.getElementById('exReps').value = workout.reps;
            document.getElementById('exNotes').value = workout.notes || '';
            document.getElementById('editingWorkoutId').value = workout.id || workout.name;
            document.getElementById('workoutFormTitle').textContent = '‚úèÔ∏è Ret √òvelse';
            document.getElementById('workoutSaveBtn').textContent = '‚úì Gem √Ündringer';
            
            document.querySelector('.add-form').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function saveWorkout() {
            const name = document.getElementById('exName').value;
            const sets = document.getElementById('exSets').value;
            const reps = document.getElementById('exReps').value;
            const notes = document.getElementById('exNotes').value;
            const editingId = document.getElementById('editingWorkoutId').value;

            if (!name || !sets || !reps) {
                alert('Udfyld √∏velse, s√¶t og reps');
                return;
            }

            if (editingId) {
                // Check if it's a custom workout (has numeric id)
                const isCustom = !isNaN(editingId);
                
                if (isCustom) {
                    // Editing existing custom workout
                    const idx = state.customWorkouts[state.selectedDay]?.findIndex(w => w.id == editingId);
                    
                    if (idx >= 0) {
                        state.customWorkouts[state.selectedDay][idx] = {
                            id: state.customWorkouts[state.selectedDay][idx].id,
                            name,
                            sets,
                            reps,
                            notes
                        };
                    }
                } else {
                    // Editing a default workout - convert to custom
                    if (!state.customWorkouts[state.selectedDay]) state.customWorkouts[state.selectedDay] = [];
                    
                    // Check if we already converted this one
                    const existingIdx = state.customWorkouts[state.selectedDay].findIndex(w => w.originalName === editingId);
                    
                    if (existingIdx >= 0) {
                        // Update existing converted workout
                        state.customWorkouts[state.selectedDay][existingIdx] = {
                            id: state.customWorkouts[state.selectedDay][existingIdx].id,
                            originalName: editingId,
                            name,
                            sets,
                            reps,
                            notes
                        };
                    } else {
                        // Create new converted workout and mark the original as hidden
                        state.customWorkouts[state.selectedDay].push({ 
                            id: Date.now(), 
                            originalName: editingId,
                            name, 
                            sets, 
                            reps, 
                            notes 
                        });
                    }
                }
            } else {
                // Adding new workout
                if (!state.customWorkouts[state.selectedDay]) state.customWorkouts[state.selectedDay] = [];
                state.customWorkouts[state.selectedDay].push({ id: Date.now(), name, sets, reps, notes });
            }

            // Reset form
            document.getElementById('exName').value = '';
            document.getElementById('exSets').value = '';
            document.getElementById('exReps').value = '';
            document.getElementById('exNotes').value = '';
            document.getElementById('editingWorkoutId').value = '';
            document.getElementById('workoutFormTitle').textContent = '+ Tilf√∏j √òvelse';
            document.getElementById('workoutSaveBtn').textContent = '+ Tilf√∏j √òvelse';

            save();
            render();
        }

        function confirmDeleteWorkout(id, isCustom) {
            if (confirm('Er du sikker p√• at du vil slette denne √∏velse?')) {
                if (isCustom) {
                    state.customWorkouts[state.selectedDay] = state.customWorkouts[state.selectedDay].filter(w => w.id != id);
                }
                save();
                render();
            }
        }

        function showWeightGraph() {
            const history = state.weightHistory.slice(-20); // Last 20 entries
            if (history.length === 0) {
                alert('Ingen v√¶gtdata endnu');
                return;
            }

            const maxWeight = Math.max(...history.map(h => h.weight), state.startWeight);
            const minWeight = Math.min(...history.map(h => h.weight), state.goalWeight);
            const range = maxWeight - minWeight;

            const graphHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: flex; align-items: center; justify-content: center; padding: 20px" onclick="this.remove()">
                    <div class="card" style="max-width: 800px; width: 100%; max-height: 90vh; overflow-y: auto" onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px">
                            <h2 style="margin: 0">V√¶gtprogression</h2>
                            <button class="delete-btn" onclick="this.closest('[style*=fixed]').remove()">Luk</button>
                        </div>
                        
                        <div style="background: var(--bg-dark); padding: 20px; border-radius: 12px; position: relative; height: 300px">
                            <svg width="100%" height="100%" style="overflow: visible">
                                ${history.map((h, i) => {
                                    const x = (i / (history.length - 1)) * 100;
                                    const y = 100 - ((h.weight - minWeight) / range) * 80;
                                    return `<circle cx="${x}%" cy="${y}%" r="4" fill="var(--primary)"/>`;
                                }).join('')}
                                
                                <polyline 
                                    points="${history.map((h, i) => {
                                        const x = (i / (history.length - 1)) * 100;
                                        const y = 100 - ((h.weight - minWeight) / range) * 80;
                                        return `${x},${y}`;
                                    }).join(' ')}" 
                                    fill="none" 
                                    stroke="var(--primary)" 
                                    stroke-width="2"
                                    vector-effect="non-scaling-stroke"
                                />
                                
                                ${state.goalWeight >= minWeight && state.goalWeight <= maxWeight ? `
                                    <line 
                                        x1="0%" 
                                        y1="${100 - ((state.goalWeight - minWeight) / range) * 80}%" 
                                        x2="100%" 
                                        y2="${100 - ((state.goalWeight - minWeight) / range) * 80}%" 
                                        stroke="var(--success)" 
                                        stroke-width="2" 
                                        stroke-dasharray="5,5"
                                        vector-effect="non-scaling-stroke"
                                    />
                                ` : ''}
                            </svg>
                        </div>

                        <div style="margin-top: 20px">
                            <div class="stat-grid">
                                <div class="stat-box">
                                    <div class="value">${history[0].weight}</div>
                                    <div class="label">START</div>
                                </div>
                                <div class="stat-box">
                                    <div class="value">${history[history.length-1].weight}</div>
                                    <div class="label">SENESTE</div>
                                </div>
                                <div class="stat-box">
                                    <div class="value">${(history[0].weight - history[history.length-1].weight).toFixed(1)}</div>
                                    <div class="label">√ÜNDRING</div>
                                </div>
                            </div>
                        </div>

                        <div style="margin-top: 20px">
                            <h3 style="font-size: 1.2rem; margin-bottom: 10px">Historik</h3>
                            <ul class="item-list">
                                ${history.slice().reverse().map(h => `
                                    <li class="item">
                                        <span>${h.date}</span>
                                        <strong style="color: var(--primary)">${h.weight} kg</strong>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', graphHTML);
        }

        function editMeal(nameOrId, isCustom) {
            const allMeals = [...(MEALS[state.selectedDay] || []), ...(state.customMeals[state.selectedDay] || [])];
            const meal = allMeals.find(m => (m.name || m.id) == nameOrId);
            if (!meal) return;

            const newName = prompt('M√•ltid navn:', meal.name);
            const newDesc = prompt('Beskrivelse:', meal.desc);
            
            if (newName && newDesc) {
                if (isCustom) {
                    const idx = state.customMeals[state.selectedDay].findIndex(m => m.id == nameOrId);
                    if (idx >= 0) {
                        state.customMeals[state.selectedDay][idx] = {
                            ...state.customMeals[state.selectedDay][idx],
                            name: newName,
                            desc: newDesc
                        };
                    }
                } else {
                    // Convert to custom meal
                    if (!state.customMeals[state.selectedDay]) state.customMeals[state.selectedDay] = [];
                    state.customMeals[state.selectedDay].push({
                        id: Date.now(),
                        name: newName,
                        desc: newDesc
                    });
                    // Remove from default by marking it completed to hide
                }
                save();
                render();
            }
        }

        function editWorkout(nameOrId, isCustom) {
            const allWorkouts = [...(WORKOUTS[state.selectedDay] || []), ...(state.customWorkouts[state.selectedDay] || [])];
            const workout = allWorkouts.find(w => (w.name || w.id) == nameOrId);
            if (!workout) return;

            const newName = prompt('√òvelse navn:', workout.name);
            const newSets = prompt('S√¶t:', workout.sets);
            const newReps = prompt('Reps/Tid:', workout.reps);
            const newNotes = prompt('Noter (valgfri):', workout.notes || '');
            
            if (newName && newSets && newReps) {
                if (isCustom) {
                    const idx = state.customWorkouts[state.selectedDay].findIndex(w => w.id == nameOrId);
                    if (idx >= 0) {
                        state.customWorkouts[state.selectedDay][idx] = {
                            ...state.customWorkouts[state.selectedDay][idx],
                            name: newName,
                            sets: newSets,
                            reps: newReps,
                            notes: newNotes
                        };
                    }
                } else {
                    // Convert to custom workout
                    if (!state.customWorkouts[state.selectedDay]) state.customWorkouts[state.selectedDay] = [];
                    state.customWorkouts[state.selectedDay].push({
                        id: Date.now(),
                        name: newName,
                        sets: newSets,
                        reps: newReps,
                        notes: newNotes
                    });
                }
                save();
                render();
            }
        }

        function toggleEditMode(section) {
            if (section === 'stats') {
                if (state.editMode.stats) {
                    // Exiting edit mode - save weight and goals BEFORE toggling
                    // Read values while inputs still exist
                    const startInput = document.getElementById('startWeightInput');
                    const goalInput = document.getElementById('goalWeightInput');
                    
                    console.log('=== TOGGLE EDIT MODE (stats) ===');
                    console.log('Exiting edit mode, saving values...');
                    console.log('Start input:', startInput ? startInput.value : 'NOT FOUND');
                    console.log('Goal input:', goalInput ? goalInput.value : 'NOT FOUND');
                    
                    // Update goals from inputs
                    if (startInput && startInput.value) {
                        state.startWeight = parseFloat(startInput.value);
                        console.log('Updated startWeight to:', state.startWeight);
                    }
                    if (goalInput && goalInput.value) {
                        state.goalWeight = parseFloat(goalInput.value);
                        console.log('Updated goalWeight to:', state.goalWeight);
                    }
                    
                    // Update current weight
                    updateWeight();
                    
                    // Save to localStorage
                    save();
                }
                state.editMode.stats = !state.editMode.stats;
                state.tempWeight = state.weight; // Reset temp weight to current
            } else {
                state.editMode[section] = !state.editMode[section];
            }
            render();
        }

        function showWeightGraph() {
            const history = state.weightHistory.slice(-20);
            if (history.length === 0) {
                alert('Ingen v√¶gtdata endnu');
                return;
            }

            const maxWeight = Math.max(...history.map(h => h.weight), state.startWeight);
            const minWeight = Math.min(...history.map(h => h.weight), state.goalWeight);
            const range = maxWeight - minWeight || 1;

            const graphHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: flex; align-items: center; justify-content: center; padding: 20px" onclick="this.remove()">
                    <div class="card" style="max-width: 900px; width: 100%; max-height: 90vh; overflow-y: auto" onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px">
                            <h2 style="margin: 0">V√¶gtprogression</h2>
                            <button class="delete-btn" onclick="this.closest('[style*=fixed]').remove()">Luk</button>
                        </div>
                        
                        <div style="background: var(--bg-dark); padding: 30px 20px; border-radius: 12px; position: relative; height: 350px; border: 2px solid var(--border);">
                            <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none">
                                <defs>
                                    <linearGradient id="areaGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:var(--primary);stop-opacity:0.3" />
                                        <stop offset="100%" style="stop-color:var(--primary);stop-opacity:0" />
                                    </linearGradient>
                                </defs>
                                
                                <!-- Grid lines -->
                                ${[20, 40, 60, 80].map(y => `<line x1="0" y1="${y}" x2="100" y2="${y}" stroke="rgba(255,255,255,0.1)" stroke-width="0.2" vector-effect="non-scaling-stroke"/>`).join('')}
                                
                                <!-- Goal line -->
                                ${state.goalWeight >= minWeight && state.goalWeight <= maxWeight ? `
                                    <line 
                                        x1="0" 
                                        y1="${100 - ((state.goalWeight - minWeight) / range) * 80}" 
                                        x2="100" 
                                        y2="${100 - ((state.goalWeight - minWeight) / range) * 80}" 
                                        stroke="var(--success)" 
                                        stroke-width="0.5" 
                                        stroke-dasharray="3,3"
                                        vector-effect="non-scaling-stroke"
                                    />
                                ` : ''}
                                
                                <!-- Area fill -->
                                <polygon 
                                    points="${history.map((h, i) => {
                                        const x = (i / (history.length - 1)) * 100;
                                        const y = 100 - ((h.weight - minWeight) / range) * 80;
                                        return `${x},${y}`;
                                    }).join(' ')} 100,100 0,100" 
                                    fill="url(#areaGradient)"
                                />
                                
                                <!-- Main line -->
                                <polyline 
                                    points="${history.map((h, i) => {
                                        const x = (i / (history.length - 1)) * 100;
                                        const y = 100 - ((h.weight - minWeight) / range) * 80;
                                        return `${x},${y}`;
                                    }).join(' ')}" 
                                    fill="none" 
                                    stroke="var(--primary)" 
                                    stroke-width="0.8"
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    vector-effect="non-scaling-stroke"
                                />
                                
                                <!-- Data points -->
                                ${history.map((h, i) => {
                                    const x = (i / (history.length - 1)) * 100;
                                    const y = 100 - ((h.weight - minWeight) / range) * 80;
                                    return `<circle cx="${x}" cy="${y}" r="1" fill="var(--primary)" vector-effect="non-scaling-stroke"/>`;
                                }).join('')}
                            </svg>
                        </div>

                        <div style="margin-top: 20px">
                            <div class="stat-grid">
                                <div class="stat-box">
                                    <div class="value">${history[0].weight} <span style="font-size: 1.5rem">kg</span></div>
                                    <div class="label">START</div>
                                </div>
                                <div class="stat-box">
                                    <div class="value">${history[history.length-1].weight} <span style="font-size: 1.5rem">kg</span></div>
                                    <div class="label">SENESTE</div>
                                </div>
                                <div class="stat-box">
                                    <div class="value">${(history[0].weight - history[history.length-1].weight).toFixed(1)} <span style="font-size: 1.5rem">kg</span></div>
                                    <div class="label">√ÜNDRING</div>
                                </div>
                            </div>
                        </div>

                        <div style="margin-top: 20px">
                            <h3 style="font-size: 1.2rem; margin-bottom: 10px">Historik</h3>
                            <ul class="item-list">
                                ${history.slice().reverse().map((h, idx) => `
                                    <li class="item">
                                        <div>
                                            <span>${h.date}</span>
                                            <strong style="color: var(--primary); margin-left: 10px">${h.weight} kg</strong>
                                        </div>
                                        <button class="delete-icon" onclick="deleteWeightEntryByIndex(${history.length - 1 - idx})">‚úï</button>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', graphHTML);
        }

        // Initialize app when page loads
        initApp();
    </script>
</body>
</html>